@page "/{*remaining}"
@using CSCDNMA.Model;
@using CwctMa.Model.Xmd
@using CwctMa.Helpers
@using Markdig
@using System.IO
@using Markdig.Extensions.Xmd;
@using Markdig.Extensions.Xmd.CSCode;
@using Markdig.Prism;
@using MathJaxBlazor;
@using Microsoft.AspNetCore.Html
@inject ILogger<Index> _logger;
@inject IJSRuntime _jsRuntime;
@inherits MathJaxContentComponent
// Fix math rendering

@if(content != null && CurrentPage == Remaining) {
    @((MarkupString)content)
}
else if(content == null)
{
    <div class="text-center">
        <div class="spinner-border inline" role="status">
            <span class="display-hidden">Loading...</span>
        </div>
        <p>Loading...</p>
    </div>
}

<PageTitle>@title - @Globals.Config.ShortName</PageTitle>

@code {
    [Parameter]
    public string Remaining { get; set; }

    public IEnumerable<string> RemainingList => Remaining?.Split("/");

    public string CurrentPage { get; set; }


    string title = "Loading...";

    public MarkdownPipeline _markdownPipeline;
    public string content;
    public string FileName
    {
        get
        {
            var fn = Path.Combine(Globals.ContentDirectory, $"{(Remaining ?? "index").Replace(".xmd", "", StringComparison.OrdinalIgnoreCase).Replace(".php", "", StringComparison.OrdinalIgnoreCase).Replace(".cshtml", "", StringComparison.OrdinalIgnoreCase).Replace(".html", "", StringComparison.OrdinalIgnoreCase).Replace(".htm", "", StringComparison.OrdinalIgnoreCase)}.xmd");
            try
            {
                fn = fn.GetActualFileName();
            }
            catch (FileNotFoundException fex)
            {
                _logger.LogWarning(fex, "No file!");
            }
            return fn;
        }
    }

    protected override Task OnInitializedAsync()
    {
        CSCodeOptions options = new()
        {
            OptimizationLevel = Microsoft.CodeAnalysis.OptimizationLevel.Release,
#if RELEASE
            MinimumLogLevel = LogLevel.Warning,
#else
            MinimumLogLevel = LogLevel.Trace,
#endif
            WorkingDirectory = Globals.ContentDirectory
        };
        _markdownPipeline = new MarkdownPipelineBuilder().UseAdvancedExtensions().UsePrism().UseXmdLanguage(options).Build();
        //content = await LoadPageContent();
        return base.OnInitializedAsync();
    }
    protected override async Task OnParametersSetAsync()
    {
        Remaining ??= "index";

        if (CurrentPage != Remaining)
        {
            await _jsRuntime.InvokeVoidAsync("removeElementsByClass", "code-toolbar"); // Fixes issue caused by PrismJS
            title = "Loading...";
            content = null;
            StateHasChanged();
            content = await LoadPageContent();
            StateHasChanged();
        }
    }

    private async Task<string> LoadPageContent()
    {
        CurrentPage = Remaining;
        if (File.Exists(FileName))
        {
            var cdnUri = new Uri(Globals.Config.CdnUrl);
            var markdownFile = await File.ReadAllTextAsync(FileName);
            var header = $"{markdownFile[..(markdownFile.IndexOf("</metadata>", StringComparison.OrdinalIgnoreCase) + "</metadata>".Length)]}";
            var meta = header.ParseXml<Metadata>();
            title = meta.Title;
            markdownFile = markdownFile[header.Count()..];

            foreach (var t in Enum.GetNames<AssetType>())
            {
                markdownFile = markdownFile.Replace($"${{assetTypeRoot:{t}}}", $"${{cdnRoot}}{t.ToLowerInvariant()}/", StringComparison.OrdinalIgnoreCase);
            }
            markdownFile = markdownFile.Replace($"${{cdnRoot}}", "https://${cdnHost}/", StringComparison.OrdinalIgnoreCase);
            markdownFile = markdownFile.Replace($"${{cdnScheme}}", $"{cdnUri.Scheme}", StringComparison.OrdinalIgnoreCase);
            markdownFile = markdownFile.Replace($"${{cdnHost}}", $"{cdnUri.DnsSafeHost}", StringComparison.OrdinalIgnoreCase);
            var content = Markdown.ToHtml(markdownFile, _markdownPipeline);

            if (meta.ShowModifiedAt)
            {
                content += $"""<p style="text-align: right;">Created{(meta.ReleasedAt == meta.ModifiedAt ? " and last modified" : "")} at <b>{meta.ReleasedAt.ToSqlTimeString().Replace("T", " ")}</b></p>""";
                if (meta.ReleasedAt != meta.ModifiedAt)
                {
                    content += "\r\n" + $"""<p style="text-align: right;">Last modified at <b>{meta.ModifiedAt.ToSqlTimeString().Replace("T"," ")}</b></p>""";
                }
            }

            return content;
        }
        else
        {
            title = "Not found";
            return Markdown.ToHtml("]>danger< # Error 404\r\n] Sorry, there's nothing at this address.", _markdownPipeline);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        //await _jsRuntime.InvokeVoidAsync("removeElementsByClass", "code-toolbar");
        await _jsRuntime.InvokeVoidAsync("Prism.highlightAll");
    }
}